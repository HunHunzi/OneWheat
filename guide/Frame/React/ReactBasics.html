<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | 一粒麦子</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/OneWheat/wheat.png">
    <meta name="description" content="一粒麦子不落在地里死了，仍旧是一粒。若死了，就结出许多子粒来。">
    
    <link rel="preload" href="/OneWheat/assets/css/0.styles.1c77ed66.css" as="style"><link rel="preload" href="/OneWheat/assets/js/app.209f0906.js" as="script"><link rel="preload" href="/OneWheat/assets/js/2.8e3b7747.js" as="script"><link rel="preload" href="/OneWheat/assets/js/1.5a416044.js" as="script"><link rel="preload" href="/OneWheat/assets/js/29.083f3b7b.js" as="script"><link rel="prefetch" href="/OneWheat/assets/js/10.db54c986.js"><link rel="prefetch" href="/OneWheat/assets/js/11.be71ba10.js"><link rel="prefetch" href="/OneWheat/assets/js/12.8aa070e7.js"><link rel="prefetch" href="/OneWheat/assets/js/13.352876c3.js"><link rel="prefetch" href="/OneWheat/assets/js/14.aa7e042f.js"><link rel="prefetch" href="/OneWheat/assets/js/15.b7440231.js"><link rel="prefetch" href="/OneWheat/assets/js/16.767a3a88.js"><link rel="prefetch" href="/OneWheat/assets/js/17.e290fa5a.js"><link rel="prefetch" href="/OneWheat/assets/js/18.baeb50d2.js"><link rel="prefetch" href="/OneWheat/assets/js/19.9f389a20.js"><link rel="prefetch" href="/OneWheat/assets/js/20.39d588d5.js"><link rel="prefetch" href="/OneWheat/assets/js/21.d04ba12b.js"><link rel="prefetch" href="/OneWheat/assets/js/22.dac4f624.js"><link rel="prefetch" href="/OneWheat/assets/js/23.b3950be4.js"><link rel="prefetch" href="/OneWheat/assets/js/24.35623e7c.js"><link rel="prefetch" href="/OneWheat/assets/js/25.690dfaff.js"><link rel="prefetch" href="/OneWheat/assets/js/26.277c1727.js"><link rel="prefetch" href="/OneWheat/assets/js/27.aacffea8.js"><link rel="prefetch" href="/OneWheat/assets/js/28.937e885e.js"><link rel="prefetch" href="/OneWheat/assets/js/3.963f93b8.js"><link rel="prefetch" href="/OneWheat/assets/js/30.06a5df8a.js"><link rel="prefetch" href="/OneWheat/assets/js/31.4af3e4e6.js"><link rel="prefetch" href="/OneWheat/assets/js/32.00e59dbf.js"><link rel="prefetch" href="/OneWheat/assets/js/33.a8ba1648.js"><link rel="prefetch" href="/OneWheat/assets/js/4.8d42542a.js"><link rel="prefetch" href="/OneWheat/assets/js/5.edbb760b.js"><link rel="prefetch" href="/OneWheat/assets/js/6.7a8bd171.js"><link rel="prefetch" href="/OneWheat/assets/js/7.93fcf6e6.js"><link rel="prefetch" href="/OneWheat/assets/js/vendors~docsearch.5a4296f1.js">
    <link rel="stylesheet" href="/OneWheat/assets/css/0.styles.1c77ed66.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/OneWheat/" class="home-link router-link-active"><img src="/OneWheat/wheat.png" alt="一粒麦子" class="logo"> <span class="site-name can-hide">一粒麦子</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/OneWheat/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/OneWheat/guide/basic/Javascript/" class="nav-link">
  JavaScript相关
</a></li><li class="dropdown-item"><!----> <a href="/OneWheat/guide/basic/Typescript/" class="nav-link">
  TypeScript相关
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架总结" class="dropdown-title"><span class="title">框架总结</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架总结" class="mobile-dropdown-title"><span class="title">框架总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/OneWheat/guide/Frame/React/" class="nav-link router-link-active">
  React相关
</a></li><li class="dropdown-item"><!----> <a href="/OneWheat/guide/Frame/Vue/" class="nav-link">
  Vue相关
</a></li></ul></div></div><div class="nav-item"><a href="/OneWheat/guide/Others/Hello.html" class="nav-link">
  碎碎念
</a></div><div class="nav-item"><a href="https://blog.csdn.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  MyBlog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/OneWheat/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/OneWheat/guide/basic/Javascript/" class="nav-link">
  JavaScript相关
</a></li><li class="dropdown-item"><!----> <a href="/OneWheat/guide/basic/Typescript/" class="nav-link">
  TypeScript相关
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架总结" class="dropdown-title"><span class="title">框架总结</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架总结" class="mobile-dropdown-title"><span class="title">框架总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/OneWheat/guide/Frame/React/" class="nav-link router-link-active">
  React相关
</a></li><li class="dropdown-item"><!----> <a href="/OneWheat/guide/Frame/Vue/" class="nav-link">
  Vue相关
</a></li></ul></div></div><div class="nav-item"><a href="/OneWheat/guide/Others/Hello.html" class="nav-link">
  碎碎念
</a></div><div class="nav-item"><a href="https://blog.csdn.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  MyBlog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/OneWheat/guide/Frame/React/ReactBasics.html" aria-current="page" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-简介" class="sidebar-link">React 简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-的三个-api" class="sidebar-link">React 的三个 API</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#jsx" class="sidebar-link">JSX</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#虚拟-dom" class="sidebar-link">虚拟 DOM</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#事件" class="sidebar-link">事件</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#props" class="sidebar-link">props</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#state" class="sidebar-link">state</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#ref-获取-dom-对象" class="sidebar-link">Ref(获取 DOM 对象)</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-中的类组件" class="sidebar-link">react 中的类组件</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-中的-cssmodule" class="sidebar-link">react 中的 CSSModule</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-中的-fragment" class="sidebar-link">react 中的 Fragment</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-中的-context" class="sidebar-link">react 中的 context</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-中的-effect" class="sidebar-link">react 中的 Effect</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-中的-setstate-的执行过程" class="sidebar-link">react 中的 setState 的执行过程</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#受控组件" class="sidebar-link">受控组件</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#非受控组件" class="sidebar-link">非受控组件</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#reducer" class="sidebar-link">Reducer</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-中的-memo" class="sidebar-link">react 中的 memo</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#usecallback" class="sidebar-link">useCallBack()</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#fectch-api" class="sidebar-link">Fectch API</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#自定义钩子" class="sidebar-link">自定义钩子</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#redux" class="sidebar-link">Redux</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#react-router" class="sidebar-link">React-Router</a></li><li class="sidebar-sub-header"><a href="/OneWheat/guide/Frame/React/ReactBasics.html#再谈-hook" class="sidebar-link">再谈 Hook</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" class="header-anchor">#</a> React</h1> <h2 id="react-简介"><a href="#react-简介" class="header-anchor">#</a> React 简介</h2> <h3 id="react-的三个-api"><a href="#react-的三个-api" class="header-anchor">#</a> React 的三个 API</h3> <ol><li><p>React.createElement() //创建虚拟 DOM</p> <ul><li>例子：<code>const button = React.createElement(&quot;button&quot;, {id: &quot;btn&quot;,type:&quot;button&quot;,className=&quot;hello&quot;,onClick=&quot;()=&gt;{alter(&quot;click&quot;)}&quot;}, &quot;按钮&quot;); //创建一个 button 标签，id 为 btn，内容为按钮</code></li> <li>参数 1：标签名(元素的名称)</li> <li>参数 2：标签中的属性
<ul><li>设置事件的时候，属性名必须是 on+事件名，属性值必须是一个函数(使用驼峰命名法)</li></ul></li> <li>参数 3：标签中的内容(子元素)
<ul><li>React 元素最终会通过虚拟 DOM 转化为真实的 DOM 元素</li> <li>React 元素是不可变的，一旦创建就不能修改它的子元素或者属性</li> <li>React 元素只是一个普通的 JavaScript 对象，它的创建非常的廉价，因此 React 应用中一般会创建大量的 React 元素</li> <li>在进行修改替换后，一定要使用 ReactDom.render()重新渲染，在重新渲染的时候 react 会对比新旧虚拟 DOM，只会修改改变的部分，不会重新渲染整个页面，这样可以提高性能</li></ul></li></ul></li> <li><p>React.Component() //创建组件</p></li> <li><p>React.render() //渲染组件</p></li> <li><p>ReactDom.createRoot() //创建根组件</p> <ul><li><code>const root = ReactDom.createRoot(document.getElementById(&quot;root&quot;));</code> //创建根组件</li> <li><code>root.render(&lt;App /&gt;);</code> //渲染根组件</li> <li>在 id=&quot;root&quot;的 div 中渲染 App 组件</li></ul></li></ol> <h3 id="jsx"><a href="#jsx" class="header-anchor">#</a> JSX</h3> <ol><li><p>JSX 是一种语法糖，它可以让我们在 js 中书写 html 代码，它会被 babel 转换为 React.createElement()的形式</p> <ul><li>例子： <code>const button = &lt;button id=&quot;btn&quot; type=&quot;button&quot; className=&quot;hello&quot; onClick={()=&gt;{alter(&quot;click&quot;)}}&gt;按钮&lt;/button&gt;;</code>//创建一个 button 标签，id 为 btn，内容为按钮</li></ul></li> <li><p>注意事项</p> <ul><li>JSX 中的属性名必须使用驼峰命名法</li> <li>JSX 中的属性值必须使用双引号</li> <li>JSX 中的内容必须使用{}包裹</li> <li>JSX 中的注释必须使用{/* */}包裹</li> <li>JSX 中的表达式如果是空值，布尔值，null，undefined，会被忽略</li> <li>在 JSX 中属性可以直接在标签中设置，也可以通过对象的形式设置，如果属性名是 class，必须使用 className，如果属性名是 for，必须使用 htmlFor；style 必须使用对象的形式设置，属性名必须使用驼峰命名法，属性值必须使用字符串 例: <code>fontSize: &quot;20px&quot;</code></li></ul></li> <li><p>渲染列表{}</p> <ul><li>{} 只能用来放 js 表达式，不能放语句(if for)</li> <li>需要在语句里面操作 JSX</li> <li>例子： <code>const arr = [1,2,3,4,5]; const list = arr.map(item =&gt; &lt;li key={item}&gt;{item}&lt;/li&gt;);</code>//渲染列表
<ul><li>例： <code>if(lang===&quot;zh&quot;){return &lt;div&gt;你好&lt;/div&gt;}else{return &lt;div&gt;hello&lt;/div&gt;;}</code>//错误</li></ul></li> <li>对于数组的遍历，使用 map()
<ul><li>例： <code>const arr = data.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;);</code> //渲染列表,一定要加 key 值</li></ul></li></ul></li></ol> <h3 id="虚拟-dom"><a href="#虚拟-dom" class="header-anchor">#</a> 虚拟 DOM</h3> <ol><li>在 react 中如何渲染
<ul><li>在 react 中通过虚拟 DOM 将 react 元素和 原生的 DOM 进行映射， 通过虚拟 DOM 可以实现跨平台，例如：react-native。 但是这些操作都最终会正式的 DOM 中体现</li> <li>虚拟 DOM 的好处
<ul><li><ol><li>虚拟 DOM 可以实现跨平台</li></ol></li> <li><ol start="2"><li>虚拟 DOM 可以实现批量更新</li></ol></li> <li><ol start="3"><li>虚拟 DOM 可以实现元素的复用</li></ol></li> <li><ol start="4"><li>降低 API 的复杂程度</li></ol></li></ul></li></ul></li></ol> <ul><li>每次使用 root.render()渲染组件的时候，react 会对比新旧虚拟 DOM，只会修改改变的部分，不会重新渲染整个页面，这样可以提高性能，它会从父节点开始</li> <li>对于列表中插入一个新的元素，react 会将新的元素插入到列表的最后，而不是重新渲染整个列表，这时需要用到 key 值，它会根据 key 值来判断元素是否相同，需要渲染
<ul><li>尽量使用 id 作为 key 值</li> <li>尽量不要使用 index 作为 key 值，因为它会根据 index 来判断元素是否相同，如果列表中的元素发生改变，index 也会发生改变，这时会重新渲染整个列表</li></ul></li></ul> <h3 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h3> <ol><li>事件的定义：<code>onClick={()=&gt;{alter(&quot;click&quot;)}}</code>//事件名必须是 on+事件名，属性值必须是一个函数(使用驼峰命名法)</li> <li>事件的属性值不能直接执行代码，而是一个回调函数，不能添加()，否则会立即执行</li> <li>在 react 中无法通过 return false 来阻止默认行为，必须使用 e.preventDefault()来阻止默认行为 -例：const clickHandler = (e) =&gt; {e.preventDefault();} //阻止默认行为
<ul><li>react 事件中会传递事件对象 e</li> <li>react 中的事件不是原生的对象</li> <li>react 中的事件是合成事件，它是通过事件委托的方式绑定的，它会将所有的事件绑定到 document 上，当事件触发时，会根据事件的类型，找到对应的事件处理函数，然后执行</li></ul></li></ol> <h3 id="props"><a href="#props" class="header-anchor">#</a> props</h3> <p>1.props 父组件传递给子组件的数据，子组件通过 props 接收数据
2.props 的值是不可修改的，它的本质是一个对象，其中包括了所有传递的数据 - 例：父组件 <code>&lt;div test=&quot;123&quot;&gt;hello&lt;/div&gt;</code> - 子组件 <code>contest = this.props.test</code>3.在子组件中使用 props，必须在构造函数中调用 <code>sst {test} = this.props;</code> //接收数据 - 或者 uper()，否则会报错
4.props 的传递是单层的，如果需要传递多层，可以使用 context，或者在子组件传递给子组件 5.在子组件中使用 props，必须在构造函数中调用 super()，否则会报错</p> <ul><li>例：<code>class App extends React.Component { constructor(props) { super(props); this.state = { name: &quot;hello&quot; } } render() { return &lt;div&gt;{this.state.name}&lt;/div&gt; } }</code></li></ul> <h3 id="state"><a href="#state" class="header-anchor">#</a> state</h3> <ol><li>state 是组件的状态，它是一个对象，其中包括了所有的状态
<ul><li>在 react 中，当组件渲染完毕后，再修改组件中的变量，不会重新渲染组件，如果需要重新渲染组件，必须使用 setState()，它会重新渲染组件</li> <li>state 相当于一个变量，但是 react 中进行了注册，当 state 发生改变时，会重新渲染组件</li> <li>在函数组件中，需要使用钩子函数，获取 state useState() -该函数会返回一个数组，数组中的第一个元素就是初始值，第二个元素是一个函数，用来修改 state
<ul><li>例：<code>consrt result = useState(0);</code></li> <li><code>let counter = result[0];</code></li> <li><code>let setCount = result[1];</code>//result[0]为初始值，result[1]为修改 state 的函数</li> <li><code>const [counter,setCounter] = useState;</code></li></ul></li> <li>如果直接修改旧的 state，不会重新渲染组件，由于对象还是原来的对象，所以 react 会认为 state 没有发生改变，不会重新渲染组件</li> <li>state 的值是一个对象时，修改是用新的对象去替换旧的对象</li> <li>通过 setState()修改时，并不表示修改当前的 state，而是将修改的 state 放入一个队列中，当 react 重新渲染组件时，会从队列中取出 state，然后修改 state
<ul><li>state 的更新是异步的，如果需要在 state 更新后获取最新的 state，可以使用 setState()的第二个参数，它是一个回调函数，它会在 state 更新后执行</li> <li>为了避免异步更新出现的错误，可以使用 setState()传递回调函数的形式来 i 需改 state
<ul><li>例：setCOunter(()=&gt;{ return counter + 1;}) //回调函数的返回值会称为新的 state 值，回调函数执行时，react 会将最新的 state 传递给回调函数</li></ul></li></ul></li></ul></li></ol> <h3 id="ref-获取-dom-对象"><a href="#ref-获取-dom-对象" class="header-anchor">#</a> Ref(获取 DOM 对象)</h3> <ol><li>直接从 React 处获取 DOM 对象 1.创建一个存储 DOM 对象的容器
<ul><li>使用 useRef()钩子函数 - 注意： 1. 之呢个用于函数组件或自定义钩子函数 2. 钩子函数只能直接在函数组件中调用 2.将容器传递给需要获取 DOM 对象的元素</li> <li>const 容器 = useRef(); //创建一个容器 ; 他所返回的时一个普通的 JS 对象，该对象的 current 属性指向容器中的 DOM 对象</li> <li><code>&lt;h1 ref={容器}&gt;&lt;/h1&gt;</code></li> <li>react 会自动将当前元素的 DOM 对象存储到容器中</li> <li>使用 useRef()创建的对象，可以确保每次渲染到的都是同一个对象</li> <li>当需要一个对象不会因为对象的重新渲染而改变时，最好就是使用 useRef()创建对象</li></ul></li></ol> <h3 id="react-中的类组件"><a href="#react-中的类组件" class="header-anchor">#</a> react 中的类组件</h3> <ol><li>类组件的定义：<code>class xxx extends React.Component { render(){return &lt;div&gt; hello&lt;/div&gt;}}</code> 需要继承 React.Component</li> <li>类组件的 props 是直接存到类的实例对象中，可以直接通过 this.props 获取</li> <li>类组件中的 state 直接存到类的实例对象中，可以直接通过 this.state 获取</li> <li>函数组件中，响应函数直接以函数的形式存在，可以直接调用，而类组件中的响应函数是以对象的形式存在，需要通过 this.响应函数 来调用</li></ol> <h3 id="react-中的-cssmodule"><a href="#react-中的-cssmodule" class="header-anchor">#</a> react 中的 CSSModule</h3> <ol><li>创建一个 XXX.module.css 文件，文件名必须以.module.css 结尾</li> <li>在组件中引入 css 文件;
<ul><li>import classes from &quot;...&quot;;</li></ul></li> <li>通过 classes 来设置类
-className={classes.xxx}</li> <li>css 模块可以动态地设置唯一的类名，避免了类名冲突的问题</li></ol> <h3 id="react-中的-fragment"><a href="#react-中的-fragment" class="header-anchor">#</a> react 中的 Fragment</h3> <ol><li>在 react 中，如果需要返回多个元素，必须使用一个根元素包裹，否则会报错</li> <li>React.Fragment 可以用来包裹多个元素，它不会在页面中渲染任何内容，它只是一个占位符，它可以用来包裹多个元素，但是它不会在页面中渲染任何内容</li></ol> <h3 id="react-中的-context"><a href="#react-中的-context" class="header-anchor">#</a> react 中的 context</h3> <ol><li>context 可以用来传递数据，它可以实现跨层级的数据传递</li> <li>创建一个 context 对象
<ul><li>const context = React.createContext();</li></ul></li> <li>在父组件中使用 Provider 组件包裹需要传递数据的组件,在子组件中使用 Consumer 组件接收数据
<ul><li><code>&lt;context.Provider value={数据}&gt;</code></li> <li><code>&lt;context.Consumer&gt;{(数据)=&gt;{return &lt;div&gt;{数据}&lt;/div&gt;}}&lt;/context.Consumer&gt;</code></li> <li>consume 需要一个回调函数，回调函数的参数就是传递的数据</li> <li>也可以使用 useContext()钩子函数来接收数据</li> <li>const 数据 = useContext(context);</li> <li>XXX.Provider
<ul><li>表示数据的生产者，可以用它来指定 contex 中的数据</li> <li>通过 value 来指定 context 中存储的数据，这样来该组件的所有子组件都可以使用该数据</li></ul></li> <li>当我们通过 Context 传递数据时，它会读取离他最近的一个数据，如果没有 provider 则会读取默认数据</li></ul></li></ol> <h3 id="react-中的-effect"><a href="#react-中的-effect" class="header-anchor">#</a> react 中的 Effect</h3> <ol><li>effect 副作用，它是一个函数，它会在组件渲染完毕后执行，它会在每次渲染完毕后执行，它可以直接在组件中使用</li> <li>ReactStrictMode react 的严格模式，它可以凸显出代码中存在的副作用(我们需要极力避免复杂作用的出现)，副作用会影响渲染</li> <li>useEffect()钩子函数，它可以用来代替生命周期函数，它会在组件渲染完毕后执行，它会在每次渲染完毕后执行，防止出现重复的多次的死循环渲染</li> <li>当直接在函数体中调用 setState 时，就会触发&quot;Too many re-renders&quot; 5.<code>useEffect( ()=&gt;{console.log(&quot;effect&quot;);},[state] ) //当 state 发生改变时，才会执行 effect ) useEffect 是一个钩子函数，需要一个函数作为参数</code></li> <li>默认情况下，useEffect()会在每次渲染结束的情况下都调用一次，在 useEffect()可以传递第二个参数，第二个参数是一个数组，在数组中可以指定 Effect 的依赖项，当依赖项发生改变时，才会执行 effect
<ul><li>例：<code>useEffect(()=&gt;{console.log(&quot;effect&quot;);},[state])</code> //当 state 发生改变时，才会执行 effect 6.我们在 useEffect 中用了什么就在依赖中添加上，通常将 Effect 中使用的所有的局部变量都设置为依赖项。这样一来可以确保这些值发生变化时，会触发 Effect 的执行，像 setState()是不需要添加到依赖项中的，因为它是一个固定的函数，不会发生改变 7.清除定时器，优化效率，防止内存泄漏(防抖)</li></ul></li></ol> <ul><li>例：<code>useEffect(()=&gt;{const timer = setInterval(()=&gt;{console.log(&quot;hello&quot;);},1000); return ()=&gt;{clearInterval(timer);}},[]) //清除定时器</code></li></ul> <h3 id="react-中的-setstate-的执行过程"><a href="#react-中的-setstate-的执行过程" class="header-anchor">#</a> react 中的 setState 的执行过程</h3> <ol><li>setCount --&gt; dispatchSetData() --&gt; 会先去判断，组件当前处于什么阶段(渲染阶段 非渲染阶段)，如果处于渲染阶段就不会检查 state 值是否相同，反之如果处于非渲染阶段，就会检查相同？再次判断是否需要更新组件</li> <li>如果值相同，react 在一些情况下继续执行当前组件的渲染，但是不会更新 DOM，不会触发其子组件的渲染，这次渲染不会产生实质性的效果，这种情况通常发生在值第一次相同时，或者在 componentDidUpdate()中</li> <li>写在函数体中的 setState()会在组件渲染完毕后执行，它会在每次渲染完毕后执行，它可以直接在组件中使用，而写在生命周期中的 setState()会在组件渲染完毕前执行，它只会在组件挂载时执行一次容易出现死循环</li></ol> <h3 id="受控组件"><a href="#受控组件" class="header-anchor">#</a> 受控组件</h3> <ol><li>在 react 中，可变状态通常保存在组件状态属性中，并且只能通过 useState()来更新，用户输入时通过 onChange()改变其值。这种由 react 控制的输入表单元素而改变其值的方式，称为受控组件(例如 input)</li> <li>流程： -通过初始化 state 中设置表单元素的默认值 -表单值发生改变时，调用 onChange 事件 -事件处理器通过 event 对象拿到改变后的值，并更新组件的 state -通过 setState 更新 state，触发视图的重新渲染，完成表单组件的更新</li> <li>例 1.<code>const inputChangeValue = (e) =&gt; { console.log('value ---------- ', e.target.value); setInputValue(e.target.value) }</code> 2.<code>&lt;input type='text' value={inputValue} onChange={inputChangeValue}/&gt;</code></li></ol> <h3 id="非受控组件"><a href="#非受控组件" class="header-anchor">#</a> 非受控组件</h3> <ol><li>表单数据由 DOM 元素本身处理，不接受 setState 的控制。（与传统的 html 表单输入相似，input 输入值即为最新显示值，实质为操作 DOM）【非受控组件中可以使用 ref 来操作 dom】</li> <li>流程 -输入框输入后，点击提交按钮，通过 this.inputRef 获取 input 的 DOM 属性信息</li> <li>例
<ol><li><code>&lt;input type='text' defaultValue={inputDefaultValue} ref={inputRef}/&gt; &lt;button onClick={changeValue}&gt;提交&lt;/button&gt;</code></li> <li><code>const inputRef = useRef();</code></li> <li><code>const changeValue = () =&gt; { console.log('input 的值 -- ', inputRef.current.value); }</code></li> <li>这里只有通过 ref 获取到的 input 的 DOM 属性信息，然后再调用 changeValue 方法来对 input 的值进行操作</li></ol></li></ol> <h3 id="reducer"><a href="#reducer" class="header-anchor">#</a> Reducer</h3> <ol><li>Reduce 的作用是管理组件中的 state，它是一个函数，接收两个参数，第一个参数是 state，第二个参数是 action，它会根据 action 的 type 来修改 state</li> <li>useReduce(reducer,initalArg,init) -参数：
-reducer：整合函数，该函数的返回值，会成为 state 的新值
<ul><li>reducer 在执行是，会收到两个参数，第一个参数是当前最新的 state,第二个参数是 action 它需要一个对象，在对象中会存储 dispatch 的方法
-initalArg：state 的初始值，作用和 useState 的初始值一样 -返回值 -数组 -第一个元素：state，用来获取 state 的值 -第二个元素：dispatch(派发器)，通过派发器可以发送操作 state 的命令，具体修改行为将会由另一个函数执行</li></ul></li> <li>例：<code>const [count,countDispatch] = useReducer((state,action)=&gt;{ if(action.type ===&quot;ADD&quot;{return state+1})else(...)},1);</code> <ul><li><code>const add = () =&gt; {countDispatch({type:&quot;ADD&quot;})} //派发器</code></li></ul></li> <li>为了避免 reducer 的重复创建，通常 reducer 会放在函数组件的外面，这样每次渲染时，都不会重新创建 reducer</li></ol> <h3 id="react-中的-memo"><a href="#react-中的-memo" class="header-anchor">#</a> react 中的 memo</h3> <ol><li>memo 可以用来优化函数组件，它可以防止函数组件的重复渲染，它会将函数组件的 props 进行浅比较，如果 props 没有发生改变，就不会重新渲染组件</li> <li>父组件渲染会默认导致子组件渲染，对于一些不需要重新渲染的子组件，可以使用 memo 来优化</li> <li>memo 只能用来优化函数组件，不能用来优化类组件,它是一个高阶组件，它接收另一个函数作为参数，并且会返回会一个包装过的新组件，
<ul><li>包装后组件就具有缓存功能，如果组件的 props 没有发生改变，总会返回缓存中的结果</li></ul></li> <li>例： export default React.memo(XXX);</li></ol> <h3 id="usecallback"><a href="#usecallback" class="header-anchor">#</a> useCallBack()</h3> <ol><li>useCallback()可以用来缓存函数，它会返回一个缓存后的函数，如果依赖项发生改变，才会重新缓存</li> <li>例 <code>const fn = useCallback(()=&gt;{console.log(&quot;hello&quot;)},[依赖项]) //缓存函数</code></li> <li>useCallBack()创建的回调函数不会总是 在组件重新渲染时重新创建，它会根据依赖项来决定是否重新创建，如果不写依赖项，每次渲染都会重新创建</li> <li>一定要把回调函数中使用到的所有变量都设置到依赖项上，除了 setState</li></ol> <h3 id="fectch-api"><a href="#fectch-api" class="header-anchor">#</a> Fectch API</h3> <p>1.解构赋值<code>{stu:{name,age,gender,address}}</code>//相当于 name=props.student.name 2.组件初始化时需要向服务器发送请求来加载数据<code>useEFfect(()=&gt;{ fetch(&quot;http://localhost:3000/api1/students&quot;).then( response =&gt; { console.log(&quot;联系服务器成功了&quot;,response); })</code> 2.<code>await: async function getStudents(){ const response = await fetch(&quot;http://localhost:3000/api1/students&quot;); }</code>
3.method 的使用
<code>fetch(&quot;http://localhost:3000/api1/students&quot;,{ method:&quot;POST&quot;, headers:{ &quot;Content-Type&quot;:&quot;application/json&quot; }, )</code></p> <h3 id="自定义钩子"><a href="#自定义钩子" class="header-anchor">#</a> 自定义钩子</h3> <ol><li>React 中的钩子函数只能在函数组件或自定钩子中调用
<ul><li>当我们需要将 react 中的钩子函数提取到一个公共区域时，就可以使用自定义钩子</li></ul></li> <li>自定义钩子就是一个函数，但是使用 use 开头，它可以调用其他的钩子函数</li> <li>例：
<ul><li>自定义 useFetch</li> <li>`export default function useFetch(){</li> <li>....</li> <li>return {data,loading,error}//需要将数据返回</li> <li>}`</li></ul></li></ol> <h3 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h3> <ol><li>Redux 是一个状态管理工具，它可以用来管理 react 中的状态，它可以将状态提升到全局，它可以实现跨组件的状态共享，相当于 Vuex</li> <li>`function reducer(state,action){</li> <li>switch(action.type){</li> <li>...}`</li> <li>state 表示当前的 state，可以根据这个 state 生成新的 state,action 是一个 js 对象，里边会存储操作的信息</li> <li>}</li> <li><code>const store = Redux.createStore(reducer,initstate) //创建 store,初始化值</code></li> <li>`store.subscribe(()=&gt;{
console.log(store.getState())// 当 store 中的 state 发生改变时，会触发 subscribe 中的回调函数</li> <li>})//订阅 store 的改变`</li> <li><code>store.dispatch({type:&quot;ADD&quot;})//派发 action</code></li> <li>react 的问题
<ul><li>如果 state 过于复杂，将会非常难以维护
<ul><li>可以通过对 state 进行分组，将 state 分成多个模块，创建多个 reducer，然后将其合并为一个</li></ul></li> <li>state 每次操作都需要对 state 进行复制</li> <li>case 后面的常量维护起来会比较麻烦</li></ul></li></ol> <h3 id="react-router"><a href="#react-router" class="header-anchor">#</a> React-Router</h3> <ol><li>Router 的引入需要在 app.js 中引入，使用 BrowserRouter 包裹整个项目</li> <li>里面的内容需要使用 Route 进行包裹，Route 中的 path 属性表示路径，component 属性表示组件</li> <li>Link 标签的使用，to 属性表示跳转的路径,navLink 标签的使用，activeClassName 属性表示选中的样式</li> <li>HashRouter 的使用，它会在路径前面添加一个#，可以解决刷新页面时，页面显示空白的问题;BrowserRouter 直接通过 url 地址进行组件跳转访问，当我们通过 Link 构建的链接进行跳转时，跳转并没有经过服务器，但是当我们刷新页面时，或进行普通跳转时会向服务器发送加载请求，这是请求没有经过 react router，所以会返回 404 -解决方案：1.使用 HashRouter，它会在路径前面添加一个#，可以解决刷新页面时，页面显示空白的问题
-2.使用 BrowserRouter，但是需要在服务器中配置，当服务器接收到请求时，返回 index.html 文件，这样就可以解决刷新页面时，页面显示空白的问题</li> <li>Route 中的 exact 属性表示精确匹配，当路径完全匹配时才会显示组件
<ul><li>match -- 匹配到的信息
<ul><li>isExact -- 是否精确匹配</li> <li>params -- 动态路由的参数</li></ul></li> <li>location -- 当前的路径信息</li> <li>history -- 路由跳转的方法
<ul><li><code>props.history.push({pathname:'/student/2'})//回退到之前一页</code></li> <li><code>props.history.replace({pathname:'/student/2'})//回退到上上个页面</code></li></ul></li> <li>:id -- 表示动态路由，可以通过 match.params.id 获取到动态路由的值</li></ul></li> <li>render 也可以指定要挂载的组件，它需要一个回调函数作为参数，回调函数返回值<code>render={()=&gt;&lt;student/&gt;}</code>-但是 render 不会自动传递三个参数，routePros...</li> <li>children 也可以用来指定被挂载的组件
<ul><li>和 render 类似，传递回调哈数
<ul><li>当 children 设置一个回调函数时，该组件无论路径是否匹配都会挂载</li></ul></li> <li>也可以传递组件</li> <li>除了通过 props 获取三个对象外，也可以通过钩子函数获取
<ul><li>useRouteMatch()</li> <li>useLocation()</li> <li>useHistory()</li> <li>useParams</li></ul></li></ul></li> <li>路由嵌套：<code>&lt;Route path=&quot;/about&quot;&gt;&lt;about/&gt;&lt;Route path=&quot;/about/hello&quot;&gt;&lt;hello/&gt;&lt;/Route&gt;&lt;/Route&gt;</code></li> <li>propmt 组件，弹窗组件</li> <li>redirect 组件，重定向组件, redirect 组件会在匹配到路径时，自动跳转到指定的路径
<ul><li>例：<code>&lt;Redirect from=&quot;/about&quot; to=&quot;/home&quot; /&gt;</code></li></ul></li> <li>useNavigate() //获取用于跳转页面的函数，相当于 histroy.push()</li> <li>路由的嵌套，<code>&lt;Route path=&quot;/student/*&quot; element={&lt;Student/&gt; /&gt;</code>//路由匹配，*表示匹配任意字符 - 可以直接在路由中使用 Route 进行嵌套，但是需要使用 element 属性，路径直接写当前的路径，不需要写父路径 - 子路由可以直接写在父路由中，但是需要使用 outlet 组件来显示子路由，它直接写在父组件中，相当于是路由占位符
12.navigate 组件，用于跳转页面，它会在匹配到路径时，自动跳转到指定的路径
13.navLink 组件，用于跳转页面，它会在匹配到路径时，自动添加选中的样式<code>&lt;NavLink style={(isActive)=&gt;{ return isActive? {backgroundColor:&quot;red&quot;} null }} to=&quot;/student&quot;&gt;学生管理&lt;/NavLink&gt;//导航链接，点击后跳转到指定路由</code></li></ol> <h3 id="再谈-hook"><a href="#再谈-hook" class="header-anchor">#</a> 再谈 Hook</h3> <p>1.useMemo //用来缓存数据
2.useCallback //用来缓存函数
3.useRef //用来缓存 DOM 对象
4.useImperativeHandle //用来缓存子组件的实例对象
5.useDebugValue //用来在 react 开发者工具中显示自定义的 hook 名称</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/OneWheat/assets/js/app.209f0906.js" defer></script><script src="/OneWheat/assets/js/2.8e3b7747.js" defer></script><script src="/OneWheat/assets/js/1.5a416044.js" defer></script><script src="/OneWheat/assets/js/29.083f3b7b.js" defer></script>
  </body>
</html>
