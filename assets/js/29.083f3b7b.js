(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{314:function(t,e,a){"use strict";a.r(e);var v=a(14),_=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),e("h2",{attrs:{id:"react-简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-简介"}},[t._v("#")]),t._v(" React 简介")]),t._v(" "),e("h3",{attrs:{id:"react-的三个-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-的三个-api"}},[t._v("#")]),t._v(" React 的三个 API")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("React.createElement() //创建虚拟 DOM")]),t._v(" "),e("ul",[e("li",[t._v("例子："),e("code",[t._v('const button = React.createElement("button", {id: "btn",type:"button",className="hello",onClick="()=>{alter("click")}"}, "按钮"); //创建一个 button 标签，id 为 btn，内容为按钮')])]),t._v(" "),e("li",[t._v("参数 1：标签名(元素的名称)")]),t._v(" "),e("li",[t._v("参数 2：标签中的属性\n"),e("ul",[e("li",[t._v("设置事件的时候，属性名必须是 on+事件名，属性值必须是一个函数(使用驼峰命名法)")])])]),t._v(" "),e("li",[t._v("参数 3：标签中的内容(子元素)\n"),e("ul",[e("li",[t._v("React 元素最终会通过虚拟 DOM 转化为真实的 DOM 元素")]),t._v(" "),e("li",[t._v("React 元素是不可变的，一旦创建就不能修改它的子元素或者属性")]),t._v(" "),e("li",[t._v("React 元素只是一个普通的 JavaScript 对象，它的创建非常的廉价，因此 React 应用中一般会创建大量的 React 元素")]),t._v(" "),e("li",[t._v("在进行修改替换后，一定要使用 ReactDom.render()重新渲染，在重新渲染的时候 react 会对比新旧虚拟 DOM，只会修改改变的部分，不会重新渲染整个页面，这样可以提高性能")])])])])]),t._v(" "),e("li",[e("p",[t._v("React.Component() //创建组件")])]),t._v(" "),e("li",[e("p",[t._v("React.render() //渲染组件")])]),t._v(" "),e("li",[e("p",[t._v("ReactDom.createRoot() //创建根组件")]),t._v(" "),e("ul",[e("li",[e("code",[t._v('const root = ReactDom.createRoot(document.getElementById("root"));')]),t._v(" //创建根组件")]),t._v(" "),e("li",[e("code",[t._v("root.render(<App />);")]),t._v(" //渲染根组件")]),t._v(" "),e("li",[t._v('在 id="root"的 div 中渲染 App 组件')])])])]),t._v(" "),e("h3",{attrs:{id:"jsx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[t._v("#")]),t._v(" JSX")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("JSX 是一种语法糖，它可以让我们在 js 中书写 html 代码，它会被 babel 转换为 React.createElement()的形式")]),t._v(" "),e("ul",[e("li",[t._v("例子： "),e("code",[t._v('const button = <button id="btn" type="button" className="hello" onClick={()=>{alter("click")}}>按钮</button>;')]),t._v("//创建一个 button 标签，id 为 btn，内容为按钮")])])]),t._v(" "),e("li",[e("p",[t._v("注意事项")]),t._v(" "),e("ul",[e("li",[t._v("JSX 中的属性名必须使用驼峰命名法")]),t._v(" "),e("li",[t._v("JSX 中的属性值必须使用双引号")]),t._v(" "),e("li",[t._v("JSX 中的内容必须使用{}包裹")]),t._v(" "),e("li",[t._v("JSX 中的注释必须使用{/* */}包裹")]),t._v(" "),e("li",[t._v("JSX 中的表达式如果是空值，布尔值，null，undefined，会被忽略")]),t._v(" "),e("li",[t._v("在 JSX 中属性可以直接在标签中设置，也可以通过对象的形式设置，如果属性名是 class，必须使用 className，如果属性名是 for，必须使用 htmlFor；style 必须使用对象的形式设置，属性名必须使用驼峰命名法，属性值必须使用字符串 例: "),e("code",[t._v('fontSize: "20px"')])])])]),t._v(" "),e("li",[e("p",[t._v("渲染列表{}")]),t._v(" "),e("ul",[e("li",[t._v("{} 只能用来放 js 表达式，不能放语句(if for)")]),t._v(" "),e("li",[t._v("需要在语句里面操作 JSX")]),t._v(" "),e("li",[t._v("例子： "),e("code",[t._v("const arr = [1,2,3,4,5]; const list = arr.map(item => <li key={item}>{item}</li>);")]),t._v("//渲染列表\n"),e("ul",[e("li",[t._v("例： "),e("code",[t._v('if(lang==="zh"){return <div>你好</div>}else{return <div>hello</div>;}')]),t._v("//错误")])])]),t._v(" "),e("li",[t._v("对于数组的遍历，使用 map()\n"),e("ul",[e("li",[t._v("例： "),e("code",[t._v("const arr = data.map(item => <li key={item.id}>{item.name}</li>);")]),t._v(" //渲染列表,一定要加 key 值")])])])])])]),t._v(" "),e("h3",{attrs:{id:"虚拟-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[t._v("#")]),t._v(" 虚拟 DOM")]),t._v(" "),e("ol",[e("li",[t._v("在 react 中如何渲染\n"),e("ul",[e("li",[t._v("在 react 中通过虚拟 DOM 将 react 元素和 原生的 DOM 进行映射， 通过虚拟 DOM 可以实现跨平台，例如：react-native。 但是这些操作都最终会正式的 DOM 中体现")]),t._v(" "),e("li",[t._v("虚拟 DOM 的好处\n"),e("ul",[e("li",[e("ol",[e("li",[t._v("虚拟 DOM 可以实现跨平台")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("虚拟 DOM 可以实现批量更新")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("虚拟 DOM 可以实现元素的复用")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[t._v("降低 API 的复杂程度")])])])])])])])]),t._v(" "),e("ul",[e("li",[t._v("每次使用 root.render()渲染组件的时候，react 会对比新旧虚拟 DOM，只会修改改变的部分，不会重新渲染整个页面，这样可以提高性能，它会从父节点开始")]),t._v(" "),e("li",[t._v("对于列表中插入一个新的元素，react 会将新的元素插入到列表的最后，而不是重新渲染整个列表，这时需要用到 key 值，它会根据 key 值来判断元素是否相同，需要渲染\n"),e("ul",[e("li",[t._v("尽量使用 id 作为 key 值")]),t._v(" "),e("li",[t._v("尽量不要使用 index 作为 key 值，因为它会根据 index 来判断元素是否相同，如果列表中的元素发生改变，index 也会发生改变，这时会重新渲染整个列表")])])])]),t._v(" "),e("h3",{attrs:{id:"事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[t._v("#")]),t._v(" 事件")]),t._v(" "),e("ol",[e("li",[t._v("事件的定义："),e("code",[t._v('onClick={()=>{alter("click")}}')]),t._v("//事件名必须是 on+事件名，属性值必须是一个函数(使用驼峰命名法)")]),t._v(" "),e("li",[t._v("事件的属性值不能直接执行代码，而是一个回调函数，不能添加()，否则会立即执行")]),t._v(" "),e("li",[t._v("在 react 中无法通过 return false 来阻止默认行为，必须使用 e.preventDefault()来阻止默认行为 -例：const clickHandler = (e) => {e.preventDefault();} //阻止默认行为\n"),e("ul",[e("li",[t._v("react 事件中会传递事件对象 e")]),t._v(" "),e("li",[t._v("react 中的事件不是原生的对象")]),t._v(" "),e("li",[t._v("react 中的事件是合成事件，它是通过事件委托的方式绑定的，它会将所有的事件绑定到 document 上，当事件触发时，会根据事件的类型，找到对应的事件处理函数，然后执行")])])])]),t._v(" "),e("h3",{attrs:{id:"props"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),e("p",[t._v("1.props 父组件传递给子组件的数据，子组件通过 props 接收数据\n2.props 的值是不可修改的，它的本质是一个对象，其中包括了所有传递的数据 - 例：父组件 "),e("code",[t._v('<div test="123">hello</div>')]),t._v(" - 子组件 "),e("code",[t._v("contest = this.props.test")]),t._v("3.在子组件中使用 props，必须在构造函数中调用 "),e("code",[t._v("sst {test} = this.props;")]),t._v(" //接收数据 - 或者 uper()，否则会报错\n4.props 的传递是单层的，如果需要传递多层，可以使用 context，或者在子组件传递给子组件 5.在子组件中使用 props，必须在构造函数中调用 super()，否则会报错")]),t._v(" "),e("ul",[e("li",[t._v("例："),e("code",[t._v('class App extends React.Component { constructor(props) { super(props); this.state = { name: "hello" } } render() { return <div>{this.state.name}</div> } }')])])]),t._v(" "),e("h3",{attrs:{id:"state"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" state")]),t._v(" "),e("ol",[e("li",[t._v("state 是组件的状态，它是一个对象，其中包括了所有的状态\n"),e("ul",[e("li",[t._v("在 react 中，当组件渲染完毕后，再修改组件中的变量，不会重新渲染组件，如果需要重新渲染组件，必须使用 setState()，它会重新渲染组件")]),t._v(" "),e("li",[t._v("state 相当于一个变量，但是 react 中进行了注册，当 state 发生改变时，会重新渲染组件")]),t._v(" "),e("li",[t._v("在函数组件中，需要使用钩子函数，获取 state useState() -该函数会返回一个数组，数组中的第一个元素就是初始值，第二个元素是一个函数，用来修改 state\n"),e("ul",[e("li",[t._v("例："),e("code",[t._v("consrt result = useState(0);")])]),t._v(" "),e("li",[e("code",[t._v("let counter = result[0];")])]),t._v(" "),e("li",[e("code",[t._v("let setCount = result[1];")]),t._v("//result[0]为初始值，result[1]为修改 state 的函数")]),t._v(" "),e("li",[e("code",[t._v("const [counter,setCounter] = useState;")])])])]),t._v(" "),e("li",[t._v("如果直接修改旧的 state，不会重新渲染组件，由于对象还是原来的对象，所以 react 会认为 state 没有发生改变，不会重新渲染组件")]),t._v(" "),e("li",[t._v("state 的值是一个对象时，修改是用新的对象去替换旧的对象")]),t._v(" "),e("li",[t._v("通过 setState()修改时，并不表示修改当前的 state，而是将修改的 state 放入一个队列中，当 react 重新渲染组件时，会从队列中取出 state，然后修改 state\n"),e("ul",[e("li",[t._v("state 的更新是异步的，如果需要在 state 更新后获取最新的 state，可以使用 setState()的第二个参数，它是一个回调函数，它会在 state 更新后执行")]),t._v(" "),e("li",[t._v("为了避免异步更新出现的错误，可以使用 setState()传递回调函数的形式来 i 需改 state\n"),e("ul",[e("li",[t._v("例：setCOunter(()=>{ return counter + 1;}) //回调函数的返回值会称为新的 state 值，回调函数执行时，react 会将最新的 state 传递给回调函数")])])])])])])])]),t._v(" "),e("h3",{attrs:{id:"ref-获取-dom-对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ref-获取-dom-对象"}},[t._v("#")]),t._v(" Ref(获取 DOM 对象)")]),t._v(" "),e("ol",[e("li",[t._v("直接从 React 处获取 DOM 对象 1.创建一个存储 DOM 对象的容器\n"),e("ul",[e("li",[t._v("使用 useRef()钩子函数 - 注意： 1. 之呢个用于函数组件或自定义钩子函数 2. 钩子函数只能直接在函数组件中调用 2.将容器传递给需要获取 DOM 对象的元素")]),t._v(" "),e("li",[t._v("const 容器 = useRef(); //创建一个容器 ; 他所返回的时一个普通的 JS 对象，该对象的 current 属性指向容器中的 DOM 对象")]),t._v(" "),e("li",[e("code",[t._v("<h1 ref={容器}></h1>")])]),t._v(" "),e("li",[t._v("react 会自动将当前元素的 DOM 对象存储到容器中")]),t._v(" "),e("li",[t._v("使用 useRef()创建的对象，可以确保每次渲染到的都是同一个对象")]),t._v(" "),e("li",[t._v("当需要一个对象不会因为对象的重新渲染而改变时，最好就是使用 useRef()创建对象")])])])]),t._v(" "),e("h3",{attrs:{id:"react-中的类组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-中的类组件"}},[t._v("#")]),t._v(" react 中的类组件")]),t._v(" "),e("ol",[e("li",[t._v("类组件的定义："),e("code",[t._v("class xxx extends React.Component { render(){return <div> hello</div>}}")]),t._v(" 需要继承 React.Component")]),t._v(" "),e("li",[t._v("类组件的 props 是直接存到类的实例对象中，可以直接通过 this.props 获取")]),t._v(" "),e("li",[t._v("类组件中的 state 直接存到类的实例对象中，可以直接通过 this.state 获取")]),t._v(" "),e("li",[t._v("函数组件中，响应函数直接以函数的形式存在，可以直接调用，而类组件中的响应函数是以对象的形式存在，需要通过 this.响应函数 来调用")])]),t._v(" "),e("h3",{attrs:{id:"react-中的-cssmodule"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-中的-cssmodule"}},[t._v("#")]),t._v(" react 中的 CSSModule")]),t._v(" "),e("ol",[e("li",[t._v("创建一个 XXX.module.css 文件，文件名必须以.module.css 结尾")]),t._v(" "),e("li",[t._v("在组件中引入 css 文件;\n"),e("ul",[e("li",[t._v('import classes from "...";')])])]),t._v(" "),e("li",[t._v("通过 classes 来设置类\n-className={classes.xxx}")]),t._v(" "),e("li",[t._v("css 模块可以动态地设置唯一的类名，避免了类名冲突的问题")])]),t._v(" "),e("h3",{attrs:{id:"react-中的-fragment"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-中的-fragment"}},[t._v("#")]),t._v(" react 中的 Fragment")]),t._v(" "),e("ol",[e("li",[t._v("在 react 中，如果需要返回多个元素，必须使用一个根元素包裹，否则会报错")]),t._v(" "),e("li",[t._v("React.Fragment 可以用来包裹多个元素，它不会在页面中渲染任何内容，它只是一个占位符，它可以用来包裹多个元素，但是它不会在页面中渲染任何内容")])]),t._v(" "),e("h3",{attrs:{id:"react-中的-context"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-中的-context"}},[t._v("#")]),t._v(" react 中的 context")]),t._v(" "),e("ol",[e("li",[t._v("context 可以用来传递数据，它可以实现跨层级的数据传递")]),t._v(" "),e("li",[t._v("创建一个 context 对象\n"),e("ul",[e("li",[t._v("const context = React.createContext();")])])]),t._v(" "),e("li",[t._v("在父组件中使用 Provider 组件包裹需要传递数据的组件,在子组件中使用 Consumer 组件接收数据\n"),e("ul",[e("li",[e("code",[t._v("<context.Provider value={数据}>")])]),t._v(" "),e("li",[e("code",[t._v("<context.Consumer>{(数据)=>{return <div>{数据}</div>}}</context.Consumer>")])]),t._v(" "),e("li",[t._v("consume 需要一个回调函数，回调函数的参数就是传递的数据")]),t._v(" "),e("li",[t._v("也可以使用 useContext()钩子函数来接收数据")]),t._v(" "),e("li",[t._v("const 数据 = useContext(context);")]),t._v(" "),e("li",[t._v("XXX.Provider\n"),e("ul",[e("li",[t._v("表示数据的生产者，可以用它来指定 contex 中的数据")]),t._v(" "),e("li",[t._v("通过 value 来指定 context 中存储的数据，这样来该组件的所有子组件都可以使用该数据")])])]),t._v(" "),e("li",[t._v("当我们通过 Context 传递数据时，它会读取离他最近的一个数据，如果没有 provider 则会读取默认数据")])])])]),t._v(" "),e("h3",{attrs:{id:"react-中的-effect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-中的-effect"}},[t._v("#")]),t._v(" react 中的 Effect")]),t._v(" "),e("ol",[e("li",[t._v("effect 副作用，它是一个函数，它会在组件渲染完毕后执行，它会在每次渲染完毕后执行，它可以直接在组件中使用")]),t._v(" "),e("li",[t._v("ReactStrictMode react 的严格模式，它可以凸显出代码中存在的副作用(我们需要极力避免复杂作用的出现)，副作用会影响渲染")]),t._v(" "),e("li",[t._v("useEffect()钩子函数，它可以用来代替生命周期函数，它会在组件渲染完毕后执行，它会在每次渲染完毕后执行，防止出现重复的多次的死循环渲染")]),t._v(" "),e("li",[t._v('当直接在函数体中调用 setState 时，就会触发"Too many re-renders" 5.'),e("code",[t._v('useEffect( ()=>{console.log("effect");},[state] ) //当 state 发生改变时，才会执行 effect ) useEffect 是一个钩子函数，需要一个函数作为参数')])]),t._v(" "),e("li",[t._v("默认情况下，useEffect()会在每次渲染结束的情况下都调用一次，在 useEffect()可以传递第二个参数，第二个参数是一个数组，在数组中可以指定 Effect 的依赖项，当依赖项发生改变时，才会执行 effect\n"),e("ul",[e("li",[t._v("例："),e("code",[t._v('useEffect(()=>{console.log("effect");},[state])')]),t._v(" //当 state 发生改变时，才会执行 effect 6.我们在 useEffect 中用了什么就在依赖中添加上，通常将 Effect 中使用的所有的局部变量都设置为依赖项。这样一来可以确保这些值发生变化时，会触发 Effect 的执行，像 setState()是不需要添加到依赖项中的，因为它是一个固定的函数，不会发生改变 7.清除定时器，优化效率，防止内存泄漏(防抖)")])])])]),t._v(" "),e("ul",[e("li",[t._v("例："),e("code",[t._v('useEffect(()=>{const timer = setInterval(()=>{console.log("hello");},1000); return ()=>{clearInterval(timer);}},[]) //清除定时器')])])]),t._v(" "),e("h3",{attrs:{id:"react-中的-setstate-的执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-中的-setstate-的执行过程"}},[t._v("#")]),t._v(" react 中的 setState 的执行过程")]),t._v(" "),e("ol",[e("li",[t._v("setCount --\x3e dispatchSetData() --\x3e 会先去判断，组件当前处于什么阶段(渲染阶段 非渲染阶段)，如果处于渲染阶段就不会检查 state 值是否相同，反之如果处于非渲染阶段，就会检查相同？再次判断是否需要更新组件")]),t._v(" "),e("li",[t._v("如果值相同，react 在一些情况下继续执行当前组件的渲染，但是不会更新 DOM，不会触发其子组件的渲染，这次渲染不会产生实质性的效果，这种情况通常发生在值第一次相同时，或者在 componentDidUpdate()中")]),t._v(" "),e("li",[t._v("写在函数体中的 setState()会在组件渲染完毕后执行，它会在每次渲染完毕后执行，它可以直接在组件中使用，而写在生命周期中的 setState()会在组件渲染完毕前执行，它只会在组件挂载时执行一次容易出现死循环")])]),t._v(" "),e("h3",{attrs:{id:"受控组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#受控组件"}},[t._v("#")]),t._v(" 受控组件")]),t._v(" "),e("ol",[e("li",[t._v("在 react 中，可变状态通常保存在组件状态属性中，并且只能通过 useState()来更新，用户输入时通过 onChange()改变其值。这种由 react 控制的输入表单元素而改变其值的方式，称为受控组件(例如 input)")]),t._v(" "),e("li",[t._v("流程： -通过初始化 state 中设置表单元素的默认值 -表单值发生改变时，调用 onChange 事件 -事件处理器通过 event 对象拿到改变后的值，并更新组件的 state -通过 setState 更新 state，触发视图的重新渲染，完成表单组件的更新")]),t._v(" "),e("li",[t._v("例 1."),e("code",[t._v("const inputChangeValue = (e) => { console.log('value ---------- ', e.target.value); setInputValue(e.target.value) }")]),t._v(" 2."),e("code",[t._v("<input type='text' value={inputValue} onChange={inputChangeValue}/>")])])]),t._v(" "),e("h3",{attrs:{id:"非受控组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非受控组件"}},[t._v("#")]),t._v(" 非受控组件")]),t._v(" "),e("ol",[e("li",[t._v("表单数据由 DOM 元素本身处理，不接受 setState 的控制。（与传统的 html 表单输入相似，input 输入值即为最新显示值，实质为操作 DOM）【非受控组件中可以使用 ref 来操作 dom】")]),t._v(" "),e("li",[t._v("流程 -输入框输入后，点击提交按钮，通过 this.inputRef 获取 input 的 DOM 属性信息")]),t._v(" "),e("li",[t._v("例\n"),e("ol",[e("li",[e("code",[t._v("<input type='text' defaultValue={inputDefaultValue} ref={inputRef}/> <button onClick={changeValue}>提交</button>")])]),t._v(" "),e("li",[e("code",[t._v("const inputRef = useRef();")])]),t._v(" "),e("li",[e("code",[t._v("const changeValue = () => { console.log('input 的值 -- ', inputRef.current.value); }")])]),t._v(" "),e("li",[t._v("这里只有通过 ref 获取到的 input 的 DOM 属性信息，然后再调用 changeValue 方法来对 input 的值进行操作")])])])]),t._v(" "),e("h3",{attrs:{id:"reducer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reducer"}},[t._v("#")]),t._v(" Reducer")]),t._v(" "),e("ol",[e("li",[t._v("Reduce 的作用是管理组件中的 state，它是一个函数，接收两个参数，第一个参数是 state，第二个参数是 action，它会根据 action 的 type 来修改 state")]),t._v(" "),e("li",[t._v("useReduce(reducer,initalArg,init) -参数：\n-reducer：整合函数，该函数的返回值，会成为 state 的新值\n"),e("ul",[e("li",[t._v("reducer 在执行是，会收到两个参数，第一个参数是当前最新的 state,第二个参数是 action 它需要一个对象，在对象中会存储 dispatch 的方法\n-initalArg：state 的初始值，作用和 useState 的初始值一样 -返回值 -数组 -第一个元素：state，用来获取 state 的值 -第二个元素：dispatch(派发器)，通过派发器可以发送操作 state 的命令，具体修改行为将会由另一个函数执行")])])]),t._v(" "),e("li",[t._v("例："),e("code",[t._v('const [count,countDispatch] = useReducer((state,action)=>{ if(action.type ==="ADD"{return state+1})else(...)},1);')]),t._v(" "),e("ul",[e("li",[e("code",[t._v('const add = () => {countDispatch({type:"ADD"})} //派发器')])])])]),t._v(" "),e("li",[t._v("为了避免 reducer 的重复创建，通常 reducer 会放在函数组件的外面，这样每次渲染时，都不会重新创建 reducer")])]),t._v(" "),e("h3",{attrs:{id:"react-中的-memo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-中的-memo"}},[t._v("#")]),t._v(" react 中的 memo")]),t._v(" "),e("ol",[e("li",[t._v("memo 可以用来优化函数组件，它可以防止函数组件的重复渲染，它会将函数组件的 props 进行浅比较，如果 props 没有发生改变，就不会重新渲染组件")]),t._v(" "),e("li",[t._v("父组件渲染会默认导致子组件渲染，对于一些不需要重新渲染的子组件，可以使用 memo 来优化")]),t._v(" "),e("li",[t._v("memo 只能用来优化函数组件，不能用来优化类组件,它是一个高阶组件，它接收另一个函数作为参数，并且会返回会一个包装过的新组件，\n"),e("ul",[e("li",[t._v("包装后组件就具有缓存功能，如果组件的 props 没有发生改变，总会返回缓存中的结果")])])]),t._v(" "),e("li",[t._v("例： export default React.memo(XXX);")])]),t._v(" "),e("h3",{attrs:{id:"usecallback"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" useCallBack()")]),t._v(" "),e("ol",[e("li",[t._v("useCallback()可以用来缓存函数，它会返回一个缓存后的函数，如果依赖项发生改变，才会重新缓存")]),t._v(" "),e("li",[t._v("例 "),e("code",[t._v('const fn = useCallback(()=>{console.log("hello")},[依赖项]) //缓存函数')])]),t._v(" "),e("li",[t._v("useCallBack()创建的回调函数不会总是 在组件重新渲染时重新创建，它会根据依赖项来决定是否重新创建，如果不写依赖项，每次渲染都会重新创建")]),t._v(" "),e("li",[t._v("一定要把回调函数中使用到的所有变量都设置到依赖项上，除了 setState")])]),t._v(" "),e("h3",{attrs:{id:"fectch-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fectch-api"}},[t._v("#")]),t._v(" Fectch API")]),t._v(" "),e("p",[t._v("1.解构赋值"),e("code",[t._v("{stu:{name,age,gender,address}}")]),t._v("//相当于 name=props.student.name 2.组件初始化时需要向服务器发送请求来加载数据"),e("code",[t._v('useEFfect(()=>{ fetch("http://localhost:3000/api1/students").then( response => { console.log("联系服务器成功了",response); })')]),t._v(" 2."),e("code",[t._v('await: async function getStudents(){ const response = await fetch("http://localhost:3000/api1/students"); }')]),t._v("\n3.method 的使用\n"),e("code",[t._v('fetch("http://localhost:3000/api1/students",{ method:"POST", headers:{ "Content-Type":"application/json" }, )')])]),t._v(" "),e("h3",{attrs:{id:"自定义钩子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义钩子"}},[t._v("#")]),t._v(" 自定义钩子")]),t._v(" "),e("ol",[e("li",[t._v("React 中的钩子函数只能在函数组件或自定钩子中调用\n"),e("ul",[e("li",[t._v("当我们需要将 react 中的钩子函数提取到一个公共区域时，就可以使用自定义钩子")])])]),t._v(" "),e("li",[t._v("自定义钩子就是一个函数，但是使用 use 开头，它可以调用其他的钩子函数")]),t._v(" "),e("li",[t._v("例：\n"),e("ul",[e("li",[t._v("自定义 useFetch")]),t._v(" "),e("li",[t._v("`export default function useFetch(){")]),t._v(" "),e("li",[t._v("....")]),t._v(" "),e("li",[t._v("return {data,loading,error}//需要将数据返回")]),t._v(" "),e("li",[t._v("}`")])])])]),t._v(" "),e("h3",{attrs:{id:"redux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),e("ol",[e("li",[t._v("Redux 是一个状态管理工具，它可以用来管理 react 中的状态，它可以将状态提升到全局，它可以实现跨组件的状态共享，相当于 Vuex")]),t._v(" "),e("li",[t._v("`function reducer(state,action){")]),t._v(" "),e("li",[t._v("switch(action.type){")]),t._v(" "),e("li",[t._v("...}`")]),t._v(" "),e("li",[t._v("state 表示当前的 state，可以根据这个 state 生成新的 state,action 是一个 js 对象，里边会存储操作的信息")]),t._v(" "),e("li",[t._v("}")]),t._v(" "),e("li",[e("code",[t._v("const store = Redux.createStore(reducer,initstate) //创建 store,初始化值")])]),t._v(" "),e("li",[t._v("`store.subscribe(()=>{\nconsole.log(store.getState())// 当 store 中的 state 发生改变时，会触发 subscribe 中的回调函数")]),t._v(" "),e("li",[t._v("})//订阅 store 的改变`")]),t._v(" "),e("li",[e("code",[t._v('store.dispatch({type:"ADD"})//派发 action')])]),t._v(" "),e("li",[t._v("react 的问题\n"),e("ul",[e("li",[t._v("如果 state 过于复杂，将会非常难以维护\n"),e("ul",[e("li",[t._v("可以通过对 state 进行分组，将 state 分成多个模块，创建多个 reducer，然后将其合并为一个")])])]),t._v(" "),e("li",[t._v("state 每次操作都需要对 state 进行复制")]),t._v(" "),e("li",[t._v("case 后面的常量维护起来会比较麻烦")])])])]),t._v(" "),e("h3",{attrs:{id:"react-router"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-router"}},[t._v("#")]),t._v(" React-Router")]),t._v(" "),e("ol",[e("li",[t._v("Router 的引入需要在 app.js 中引入，使用 BrowserRouter 包裹整个项目")]),t._v(" "),e("li",[t._v("里面的内容需要使用 Route 进行包裹，Route 中的 path 属性表示路径，component 属性表示组件")]),t._v(" "),e("li",[t._v("Link 标签的使用，to 属性表示跳转的路径,navLink 标签的使用，activeClassName 属性表示选中的样式")]),t._v(" "),e("li",[t._v("HashRouter 的使用，它会在路径前面添加一个#，可以解决刷新页面时，页面显示空白的问题;BrowserRouter 直接通过 url 地址进行组件跳转访问，当我们通过 Link 构建的链接进行跳转时，跳转并没有经过服务器，但是当我们刷新页面时，或进行普通跳转时会向服务器发送加载请求，这是请求没有经过 react router，所以会返回 404 -解决方案：1.使用 HashRouter，它会在路径前面添加一个#，可以解决刷新页面时，页面显示空白的问题\n-2.使用 BrowserRouter，但是需要在服务器中配置，当服务器接收到请求时，返回 index.html 文件，这样就可以解决刷新页面时，页面显示空白的问题")]),t._v(" "),e("li",[t._v("Route 中的 exact 属性表示精确匹配，当路径完全匹配时才会显示组件\n"),e("ul",[e("li",[t._v("match -- 匹配到的信息\n"),e("ul",[e("li",[t._v("isExact -- 是否精确匹配")]),t._v(" "),e("li",[t._v("params -- 动态路由的参数")])])]),t._v(" "),e("li",[t._v("location -- 当前的路径信息")]),t._v(" "),e("li",[t._v("history -- 路由跳转的方法\n"),e("ul",[e("li",[e("code",[t._v("props.history.push({pathname:'/student/2'})//回退到之前一页")])]),t._v(" "),e("li",[e("code",[t._v("props.history.replace({pathname:'/student/2'})//回退到上上个页面")])])])]),t._v(" "),e("li",[t._v(":id -- 表示动态路由，可以通过 match.params.id 获取到动态路由的值")])])]),t._v(" "),e("li",[t._v("render 也可以指定要挂载的组件，它需要一个回调函数作为参数，回调函数返回值"),e("code",[t._v("render={()=><student/>}")]),t._v("-但是 render 不会自动传递三个参数，routePros...")]),t._v(" "),e("li",[t._v("children 也可以用来指定被挂载的组件\n"),e("ul",[e("li",[t._v("和 render 类似，传递回调哈数\n"),e("ul",[e("li",[t._v("当 children 设置一个回调函数时，该组件无论路径是否匹配都会挂载")])])]),t._v(" "),e("li",[t._v("也可以传递组件")]),t._v(" "),e("li",[t._v("除了通过 props 获取三个对象外，也可以通过钩子函数获取\n"),e("ul",[e("li",[t._v("useRouteMatch()")]),t._v(" "),e("li",[t._v("useLocation()")]),t._v(" "),e("li",[t._v("useHistory()")]),t._v(" "),e("li",[t._v("useParams")])])])])]),t._v(" "),e("li",[t._v("路由嵌套："),e("code",[t._v('<Route path="/about"><about/><Route path="/about/hello"><hello/></Route></Route>')])]),t._v(" "),e("li",[t._v("propmt 组件，弹窗组件")]),t._v(" "),e("li",[t._v("redirect 组件，重定向组件, redirect 组件会在匹配到路径时，自动跳转到指定的路径\n"),e("ul",[e("li",[t._v("例："),e("code",[t._v('<Redirect from="/about" to="/home" />')])])])]),t._v(" "),e("li",[t._v("useNavigate() //获取用于跳转页面的函数，相当于 histroy.push()")]),t._v(" "),e("li",[t._v("路由的嵌套，"),e("code",[t._v('<Route path="/student/*" element={<Student/> />')]),t._v("//路由匹配，*表示匹配任意字符 - 可以直接在路由中使用 Route 进行嵌套，但是需要使用 element 属性，路径直接写当前的路径，不需要写父路径 - 子路由可以直接写在父路由中，但是需要使用 outlet 组件来显示子路由，它直接写在父组件中，相当于是路由占位符\n12.navigate 组件，用于跳转页面，它会在匹配到路径时，自动跳转到指定的路径\n13.navLink 组件，用于跳转页面，它会在匹配到路径时，自动添加选中的样式"),e("code",[t._v('<NavLink style={(isActive)=>{ return isActive? {backgroundColor:"red"} null }} to="/student">学生管理</NavLink>//导航链接，点击后跳转到指定路由')])])]),t._v(" "),e("h3",{attrs:{id:"再谈-hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再谈-hook"}},[t._v("#")]),t._v(" 再谈 Hook")]),t._v(" "),e("p",[t._v("1.useMemo //用来缓存数据\n2.useCallback //用来缓存函数\n3.useRef //用来缓存 DOM 对象\n4.useImperativeHandle //用来缓存子组件的实例对象\n5.useDebugValue //用来在 react 开发者工具中显示自定义的 hook 名称")])])}),[],!1,null,null,null);e.default=_.exports}}]);