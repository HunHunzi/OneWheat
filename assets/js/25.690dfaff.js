(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{308:function(t,s,i){"use strict";i.r(s);var v=i(14),a=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"javascript-补全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-补全"}},[t._v("#")]),t._v(" JavaScript 补全")]),t._v(" "),s("h2",{attrs:{id:"var-let-const"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#var-let-const"}},[t._v("#")]),t._v(" var let const")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("var 无块级作用域，有函数作用域（慎用），它会在所有函数的顶部声明变量，但是不会赋值，所以会出现变量提升的现象，即使在声明之前使用变量也不会报错，但是值为 undefined")])]),t._v(" "),s("li",[s("p",[t._v("let 有块级作用域，没有函数作用域，它会在块级作用域的顶部声明变量，但是不会赋值，所以会出现变量提升的现象，但是在声明之前使用变量会报错")])]),t._v(" "),s("li",[s("p",[t._v("const 无块级作用域，没有函数作用域，它会在块级作用域的顶部声明变量，但是不会赋值，所以会出现变量提升的现象，但是在声明之前使用变量会报错，它声明的变量必须赋值，且不能修改")])]),t._v(" "),s("li",[s("p",[t._v("var let const 声明的变量都会挂载到 window 上，但是 var 声明的变量可以被覆盖，let 和 const 声明的变量不能被覆盖")])]),t._v(" "),s("li",[s("p",[t._v("对于一些常量，对象，函数都可以用 const 赋值")])])]),t._v(" "),s("h2",{attrs:{id:"展开运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#展开运算符"}},[t._v("#")]),t._v(" 展开运算符")]),t._v(" "),s("ol",[s("li",[t._v("展开运算符可以展开数组，对象，字符串，类数组对象，它会将对象的属性展开，将数组的元素展开，将字符串的字符展开，将类数组对象的元素展开(...arr, ...obj, ...str, ...arguments) 展开相当于浅拷贝")])]),t._v(" "),s("h2",{attrs:{id:"箭头函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),s("ol",[s("li",[t._v("箭头函数的定义：() => {};")]),t._v(" "),s("li",[t._v("它没有 this，没有 arguments，没有 prototype，不能作为构造函数，不能使用 new，不能使用 call，apply，bind... （arguments 可以用...args 代替,它用来保存函数的参数）")])]),t._v(" "),s("p",[t._v('const fn =function(a){\nreturn "hello";\n};')]),t._v(" "),s("p",[t._v('相当于：\nconst fn = a => "hello"; //如果只有一个参数，可以省略括号')]),t._v(" "),s("p",[t._v("()=>{} 相当于 function(){},没有参数的写法\n(a,b,c)=>{} 相当于 function(a,b,c){},有参数的写法")]),t._v(" "),s("ol",[s("li",[t._v("返回值必须是表达式，如果是对象，必须用()包裹")]),t._v(" "),s("li",[t._v("箭头函数的 this 指向它的上一级作用域的 this，如果上一级作用域没有 this，就指向 window；\n例如：\nconst obj = {\nfn: function(){\nconsole.log(this); //this => obj\nconst fn2 = () => {\nconsole.log(this); //this => obj\n}\nfn2();\n}\n}")]),t._v(" "),s("li",[t._v("箭头函数的 this 指向它的上一级作用域的 this，如果上一级作用域没有 this，就指向 window；")]),t._v(" "),s("li",[t._v("箭头函数的 this 无法通过 call，apply，bind 改变")]),t._v(" "),s("li",[t._v("箭头函数无法作为构造函数，不能使用 new")])]),t._v(" "),s("h2",{attrs:{id:"模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[t._v("#")]),t._v(" 模块化")]),t._v(" "),s("ol",[s("li",[t._v("默认导出：export default xxx; //导出的是一个值，可以是任意类型")]),t._v(" "),s("li",[t._v("命名导出：export const xxx = xxx; //导出的是一个变量，可以是任意类型")])]),t._v(" "),s("h2",{attrs:{id:"类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[t._v("#")]),t._v(" 类")]),t._v(" "),s("ol",[s("li",[t._v("类的定义：class xxx {}")]),t._v(" "),s("li",[t._v("类的继承：class xxx extends xxx {} //继承父类的属性和方法，当在子类中重写父类的构造函数时，必须 super()，调用父类的构造函数")]),t._v(" "),s("li",[t._v("类对象的创建：new xxx() //创建类的实例")]),t._v(" "),s("li",[t._v("类的构造函数：constructor() {}")]),t._v(" "),s("li",[t._v("类中的所有代码都会在严格模式下执行，其中的 this 指向类的实例，而不是 window")]),t._v(" "),s("li",[t._v("对类中 this 的绑定，this.xxx = this.xxx.bind(this); //在构造函数中绑定 this,使其指向类的实例")]),t._v(" "),s("li",[t._v("在类中尽量使用箭头函数，因为箭头函数没有 this，它的 this 指向它的上一级作用域的 this，如果上一级作用域没有 this，就指向 window；")])]),t._v(" "),s("h2",{attrs:{id:"数组方法补全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组方法补全"}},[t._v("#")]),t._v(" 数组方法补全")]),t._v(" "),s("ol",[s("li",[t._v("map() //返回一个新数组，数组中的每个元素都会执行回调函数，回调函数的返回值作为新数组的元素 例： arr.map((item, index) => {return item + 1;}) //每个元素都加 1")]),t._v(" "),s("li",[t._v("filter() //过滤，返回符合条件的值的新数组")]),t._v(" "),s("li",[t._v("forEach() //遍历数组，没有返回值")]),t._v(" "),s("li",[t._v("some() //判断数组中是否有符合条件的元素，有一个符合条件就返回 true，否则返回 false")]),t._v(" "),s("li",[t._v("find() //查找数组中符合条件的元素，返回第一个符合条件的元素，没有符合条件的元素返回 undefined")]),t._v(" "),s("li",[t._v("reduce() //累加器，返回一个值，它会遍历数组，将数组中的元素依次传入回调函数，回调函数的返回值作为下一次调用回调函数的第一个参数，第一次调用回调函数时，第一个参数为初始值，如果没有初始值，第一次调用回调函数时，第一个参数为数组的第一个元素，第二个参数为数组的第二个元素，第二次调用回调函数时，第一个参数为第一次调用回调函数的返回值，第二个参数为数组的第三个元素，以此类推，直到遍历完数组，返回最后一次调用回调函数的返回值")])])])}),[],!1,null,null,null);s.default=a.exports}}]);